<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="SPI机制Dubbo的SPI机制是通过自定义注解的方式实现的，在服务启动之初，Dubbo会加载存放在META-INF/service、META-INF/dubbo、META-INF/dubbo/internal下的配置文件信息，配置文件名以对应的顶级接口类的全路径命名，内容以键值对的方式存放支持的类型； 以Protocol为例，在META-INF/dubbo/internal下有一个com.ali">
<meta name="keywords" content="源码">
<meta property="og:type" content="article">
<meta property="og:title" content="dubbo源码专题(一)">
<meta property="og:url" content="http://yoursite.com/2018/12/16/dubbo/dubbo1/index.html">
<meta property="og:site_name" content="加载中...">
<meta property="og:description" content="SPI机制Dubbo的SPI机制是通过自定义注解的方式实现的，在服务启动之初，Dubbo会加载存放在META-INF/service、META-INF/dubbo、META-INF/dubbo/internal下的配置文件信息，配置文件名以对应的顶级接口类的全路径命名，内容以键值对的方式存放支持的类型； 以Protocol为例，在META-INF/dubbo/internal下有一个com.ali">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-28T08:17:06.806Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dubbo源码专题(一)">
<meta name="twitter:description" content="SPI机制Dubbo的SPI机制是通过自定义注解的方式实现的，在服务启动之初，Dubbo会加载存放在META-INF/service、META-INF/dubbo、META-INF/dubbo/internal下的配置文件信息，配置文件名以对应的顶级接口类的全路径命名，内容以键值对的方式存放支持的类型； 以Protocol为例，在META-INF/dubbo/internal下有一个com.ali">






  <link rel="canonical" href="http://yoursite.com/2018/12/16/dubbo/dubbo1/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>dubbo源码专题(一) | 加载中...</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">加载中...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">上善若水 初心不易</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/dubbo/dubbo1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鍾欽鎮">
      <meta itemprop="description" content="他强由它强 清风拂山岗 他横由他横 明月照大江">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="加载中...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">dubbo源码专题(一)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-16 22:45:31" itemprop="dateCreated datePublished" datetime="2018-12-16T22:45:31+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-28 16:17:06" itemprop="dateModified" datetime="2018-12-28T16:17:06+08:00">2018-12-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java、Dubbo/" itemprop="url" rel="index"><span itemprop="name">Java、Dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>Dubbo的SPI机制是通过自定义注解的方式实现的，在服务启动之初，Dubbo会加载存放在<code>META-INF/service</code>、<code>META-INF/dubbo</code>、<code>META-INF/dubbo/internal</code>下的配置文件信息，配置文件名以对应的顶级接口类的全路径命名，内容以键值对的方式存放支持的类型；</p>
<p>以<code>Protocol</code>为例，在<code>META-INF/dubbo/internal</code>下有一个<code>com.alibaba.dubbo.rpc.Protocol</code>文件，内容为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock=com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line">injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line">rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class="line">hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class="line">thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class="line">memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class="line">redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class="line">rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class="line">registry=com.alibaba.dubbo.registry.integration.RegistryProtocol</span><br><span class="line">qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</span><br></pre></td></tr></table></figure>
<p>在Dubbo中，通过<code>@SPI</code>和<code>@Adaptive</code>来实现SPI机制。</p>
<ul>
<li><code>@SPI</code>代表将一个接口注册成一个扩展点，可以通过设置<code>@SPI(value)</code>来设置默认的扩展点；</li>
<li><code>@Adaptive</code>有两种用法，一种是作用于类层面，代表对应的类是自适应的扩展点实现，通过<code>getAdaptiveExtension()</code>方法会获取到该类；第二种是作用于方法层面，代表将会通过生成字节码的方式生成一个<code>XXX@Adaptive</code>的类，内部实现为获取url的属性值，非空则获取对应的扩展点，否则获取默认的扩展点；</li>
</ul>
<blockquote>
<p>1、如果@Adaptive既配置在类层面，也配置在方法层面，那么类层面的会优先生效；</p>
<p>2、配置在方法层面的@Adaptive，只需要在类中的某一个方法上配置即可，无需所有方法都配置；</p>
</blockquote>
<p>可通过<code>ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>获取自适应扩展点；</p>
<h3 id="织入逻辑（wrapper）"><a href="#织入逻辑（wrapper）" class="headerlink" title="织入逻辑（wrapper）"></a>织入逻辑（wrapper）</h3><p>在加载配置文件信息的时候，Dubbo除了会判断加载的类上是否有<code>@Adaptive</code>注解外，也会判断一个类是不是<code>wrapper</code>织入类，如果是的话，那么会记录该<code>wrapper</code>类，并在<code>XXX@Adaptive</code>中通过指定名称去获取扩展点的时候，以此用<code>wrapper</code>包装对应的扩展点，<strong>因此通过<code>XXX@Adaptive</code>获取到的扩展点，实际上可能是被<code>wrapper</code>包装过的类；</strong></p>
<p>判断一个类是不是<code>wrapper</code>的依据为：对应的类是否有带有扩展点接口参数的构造方法；</p>
<p>以<code>Protocol</code>为例，<code>ProtocolFilterWrapper</code>、<code>ProtocolListenerWrapper</code>都是织入类，因为其内部存在以下构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为织入类依据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载配置文件时对织入类的处理逻辑，记录到ConcurrentHashSet中</span></span><br><span class="line"><span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">    <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        wrappers = cachedWrapperClasses;</span><br><span class="line">    &#125;</span><br><span class="line">    wrappers.add(clazz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际创建扩展点时，如果存在织入类，织入逻辑（ExtensionLoader#createExtension）</span></span><br><span class="line"><span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入逻辑（inject）"><a href="#注入逻辑（inject）" class="headerlink" title="注入逻辑（inject）"></a>注入逻辑（inject）</h3><p>在上面的织入逻辑代码中，存在一个<code>injectExtension(T)</code>的方法，准确的说不仅仅是在织入的时候，在创建扩展点的时候都会通过该方法来实现注入其他扩展点的功能；</p>
<p>在<code>injectExtension</code>方法内部主要是通过获取传进去的实例的set方法，经过<code>objectFactory</code>去获取对应的注入对象，如果对象存在，通过反射进行设置值；</p>
<ol>
<li><p>set方法的判断依据为<strong>存在set开头的方法且方法参数为1个且方法的修饰符为public的</strong></p>
</li>
<li><p>objectFactory实际上是一个ExtensionFactory的自适应扩展点，而ExtensionFactory的子类AdaptiveExtensionFactory在类层面存在一个@Adaptive注解，所以objectFactory等同于AdaptiveExtensionFactory；AdaptiveExtensionFactory获取注入对象的逻辑为获取所有其他ExtensionFactory的扩展点，依次去获取对应的要注入的扩展点对象，获取到就返回。ExtensionFactory的其他扩展点有以下两种</p>
<ul>
<li>SpiExtensionFactory：根据SPI获取扩展点工厂；根据参数类型，判断是不是存在@SPI注解，存在获取对应的ExtensionLoader，如果存在支持的扩展点，那么获取对应的自适应扩展点进行返回；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpiExtensionFactory</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">        <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SpringExtensionFactory：Spring的获取扩展点工厂；先通过name去获取bean，获取到直接返回，否则根据class去获取，获取到则返回；</li>
</ul>
</li>
</ol>
<h3 id="自定义扩展点"><a href="#自定义扩展点" class="headerlink" title="自定义扩展点"></a>自定义扩展点</h3><ul>
<li>ExtensionFactory –&gt; AdaptiveExtensionFactory</li>
<li><p>Compile –&gt; AdaptiveCompile</p>
</li>
<li><p>Protocol –&gt; Protocol@Adaptive</p>
</li>
<li>Registry –&gt; Registry@Adaptive</li>
<li>Cluster –&gt; Cluster@Adaptive</li>
<li>ProxyFactory –&gt; ProxyFactory@Adaptive</li>
<li>…</li>
</ul>
<h2 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h2><p>Dubbo基于Spring提供的可扩展的Schema机制来完成配置文件的设置，Spring默认会加载jar包下的META-INF/spring.handlers文件寻找对应的NamespaceHandler。通过继承Spring提供的NamespaceHandlerSupport，并重写init方法来为不同的节点注册不同的DubboBeanDefinitionParser解析器，最终将解析结果注册到spring的BeanDefinition中并返回；  </p>
<blockquote>
<p>入口代码为：DubboNamespaceHandler</p>
</blockquote>
<h2 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h2><p>服务发布主要的操作流程包括：1、发布流程：开放接口建立netty连接，2、注册流程：注册服务到注册中心；</p>
<p>服务发布的入口类为ServiceBean，由于实现了InitializingBean，所以在Spring启动初始化bean的时候，可以通过afterPropertiesSet方法来启动服务发布流程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>InitializingBean：当Spring初始化bean的时候，执行对应的afterPropertiesSet方法</li>
<li>DisposableBean：当Spring销毁bean的时候，执行对应的destroy方法</li>
<li>ApplicationContextAware：当Spring容器启动的时候，执行setApplicationContext注入对应的容器</li>
<li>ApplicationListener：当Spring容器启动完毕后，发送一个对应的事件通知，执行onApplicationEvent方法</li>
<li>BeanNameAware：当Spring初始化bean时，获取自身的beanid进行注入，执行setBeanName方法</li>
</ul>
<p>在afterPropertiesSet跟onApplicationEvent都会去调用export方法，只是在调用前分别会去判断是否配置了延迟暴露(delay属性，可在\<a href="dubbo:provider" target="_blank" rel="noopener">dubbo:provider</a>或者\<a href="dubbo:service" target="_blank" rel="noopener">dubbo:service</a>中配置)；如果配置了，那么在会在afterPropertiesSet中进行调用，延迟的实现为通过创建一个<code>Executors.newSingleThreadScheduledExecutor</code>线程池来实现。如果没有配置，那么会在Spring容器启动后的onApplicationEvent方法中执行，立即进行服务发布流程；</p>
<p>在进行服务发布的过程中，都是通过<code>proxyFactory.getInvoker</code>去包装获取对应的<code>Invoker</code>对象，进而封装成<code>DelegateProviderMetaDataInvoker</code>对象，最后通过<code>protocol.export</code>进行服务发布，得到服务发布暴露对象；针对于配置了注册中心和没有配置注册中心或者配置为N/A的情况，实际上只是在获取Invoker对象时候的url不同，进而导致服务发布流程的操作不同；</p>
<ul>
<li>配置了注册中心的url格式为：registry://127.0.0.1:20880/…；而且还会将url添加到registryURL的paramter参数中；</li>
<li>没有配置注册中心的url格式为：dubbo://127.0.0.1:20880/…</li>
</ul>
<p>两者的区别在于前者会去注册中心注册相应的服务，再去暴露服务，而后者只会暴露服务；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段</span></span><br><span class="line"><span class="keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">            url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">            URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">            <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">            String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**	暴露入口*/</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">            DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">            exporters.add(exporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**	暴露入口*/</span></span><br><span class="line">        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的proxyFactory和protocol都是自适应扩展点，因此可以对应的引用对象为ProxyFactory@Adaptive和Protocol@Adaptive；同时两者都是存在织入类的。</p>
<p>ProxyFactory@Adaptive会通过wrapper跟JavassistProxyFactory（默认）进行包装，最终返回invoker对象；</p>
<p>获取到Invoker后，还会将Invoker对象和当前引用对象包装成一个DelegateProviderMetaDataInvoker类，最终传递给Protocol@Adaptive进行服务发布；</p>
<blockquote>
<p> Invoker对象是一个代理类，是用来实现最终的远程调用用的；</p>
</blockquote>
<h3 id="Protocol-Adaptive"><a href="#Protocol-Adaptive" class="headerlink" title="Protocol@Adaptive"></a>Protocol@Adaptive</h3><p>因为protocol中存在wrapper类，所以在进行protocol.export方法调用的时候，因为传递进来的url的为registry开头的，所以会调用<code>ProtocolListenerWrapper --&gt; ProtocolFilterWrapper --&gt; QosProtocolWrapper --&gt;RegistryProtocol</code>调用链（wrapper放在set集合中，无序）去调用。前面两个wrapper将会直接调用，而QosProtocolWrapper会开启一个Qos服务，用于在线运维服务；</p>
<h4 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h4><p>RegistryProtocol的服务发布逻辑主要分为两步，第一步进行本地服务暴露，通过doLocalExport方法实现，第二步则是将服务注册到对应的注册中心中去；</p>
<p>doLocalExport操作中内部实际上还是通过protocol.export进行服务发布的操作，本质上还是通过Protocol@Adaptive，注意的是，这次再次将invoker进行了包装，包装成一个InvokerDelegete类，而且传递进去的url为从原先的registryUrl对象的paramters中获取的原始url，这里为dubbo://127.0.0.1:20880/开头的url。</p>
<p>因此会依次调用<code>ProtocolListenerWrapper --&gt; ProtocolFilterWrapper --&gt; QosProtocolWrapper --&gt;DubboProtocol</code>调用链去调用，这次相反，前面两个wrapper会织入监听器及过滤器的逻辑，再会进入到DubboProtocol去进行服务发布暴露的过程；</p>
<h4 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h4><p>DubboProtocol中主要是去通过netty底层建立连接的操作，主要步骤有：</p>
<ul>
<li>通过invoker去获取对应的url，然后通过<code>openServer(url)</code>方法去发布服务；</li>
<li>openServer内部会从url中解析获取到<code>ip:port</code>格式的key，然后检测对应的key是不是已经创建了对应的心跳服务，否则通过<code>createServer(url)</code>建立服务，并设置到Map映射中；</li>
<li>createServer首先会去获取一个Exchanger对象，Exchanger也是一个扩展点，最终会获取到一个默认的HeaderExchanger对象，最终将封装好的ExchangeHandlerAdapter对象传递给HeaderExchanger进行bind的操作；</li>
<li>HeaderExchanger的bind操作会将handler进行封装，再通过Transporters进行bind的操作返回Server对象，通过HeaderExchangeServer的构造方法进行注入，最终返回一个HeaderExchangeServer对象；</li>
<li>Transporters实际上也是一个扩展点，实际上获取到的会是一个Transporters@Adaptive对象，最终会通过默认的实现NettyTransporter进行bind的操作；</li>
<li>NettyTransporter的bind操作实际上会返回一个NettyServer服务，底层最终基于Netty进行启动服务，等待连接；</li>
</ul>
<h3 id="RegistryFactory-Adaptive"><a href="#RegistryFactory-Adaptive" class="headerlink" title="RegistryFactory@Adaptive"></a>RegistryFactory@Adaptive</h3><p>通过doLocalExport方法实现建立绑定Netty服务之后，紧接着Dubbo会将注册的url信息注册到对应的注册中心去，并进行订阅监听的操作；</p>
<p>在RegistryProtocol的export方法中，发布完服务之后Dubbo通过getRegistry去获取对应的Registry对象，具体实现是通过RegistryFactory来实现的，而RegistryFactory实际上是在构建RegistryProtocol时通过注入的方式注入的自适应扩展点，也就是RegistryFactory@Adaptive；</p>
<p>RegistryFactory接口中的@SPI的value值为dubbo，也就是默认情况下是用dubbo进行注册的。而在使用Dubbo的时候推荐使用zookeeper作为注册中心，由于我们在配置文件中指定了注册中心为zookeeper，所以这里实际上是通过ZookeeperRegistryFactory.createRegistry去创建一个ZookeeperRegistry对象，期间用了模版方法，加了锁及本地缓存的操作；</p>
<h4 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h4><p>获取到ZookeeperRegistry之后，会调用register方法进行注册的动作，这个也是一个模版方法设计，实际上会通过ZookeeperRegistry.doRegister方法进行真正的注册操作。doRegister方法通过调用ZookeeperClient对象来完成对应节点的创建，而ZookeeperClient是通过ZookeeperTransporter创建的，ZookeeperTransporter是一个自适应扩展点，可以用zookeeper的api或者curator来实现。</p>
<blockquote>
<p>在调用doRegister进行注册操作的时候，采用了模版方法的方式进行操作，如果注册操作，Dubbo会记录到ConcurrentHashSet中，然后用定时器线程池延迟调用的方式进行重试，没有配置时默认为5s；</p>
</blockquote>
<p>除了注册，Dubbo还会在ZookeeperRegistry中注册监听，当对应服务的<code>provider</code>节点下的节点发生变动时（zookeeper的watcher机制），会去动态修改exporter对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务发布注册入口：ServiceBean.class</span></span><br><span class="line">ServiceBean(afterPropertiesSet/onApplicationEvent) --&gt; ServiceConfig(export --&gt; doExport --&gt; doExportUrls --&gt; doExportUrlsFor1Protocol) --&gt; xxxProxyFactoryWrapper(getProxy) --&gt; JavassistProxyFactory(getProxy) --&gt; xxxProtocolWrapper(export) --&gt; RegistryProtocol(export --&gt; doLocalExport --&gt; register)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 发布流程开始</span></span><br><span class="line">RegistryProtocol(doLocalExport) --&gt; xxxProtocolWrapper(export) --&gt; DubboProtocol(export --&gt; openServer --&gt; createServer) --&gt; HeaderExchanger(bind) --&gt; NettyTransporter(bind) --&gt; NettyServer(<span class="keyword">new</span>)</span><br><span class="line"><span class="comment">// 发布流程结束</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 注册流程开始</span></span><br><span class="line">RegistryProtocol(register) --&gt; AbstractRegistryFactory(getRegistry) --&gt; ZookeeperRegistryFactory（createRegistry） --&gt; FailbackRegistry (register) --&gt;  ZookeeperRegistry (doRegister) --&gt; ZookeeperClient(create)</span><br><span class="line"><span class="comment">// 注册流程结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听开始</span></span><br><span class="line">RegistryProtocol(export) --&gt; FailbackRegistry(subscribe) --&gt; ZookeeperRegistry(doSubscribe) --&gt; FailbackRegistry(notify --&gt; doNotify) --&gt; AbstractRegistry(notify) --&gt; RegistryProtocol$OverrideListener(notify) --&gt; RegistryProtocol(doChangeLocalExport) --&gt; exporter.setExporter(protocol.export(invokerDelegete));</span><br><span class="line"><span class="comment">// 注册监听结束</span></span><br></pre></td></tr></table></figure>
<h2 id="服务订阅"><a href="#服务订阅" class="headerlink" title="服务订阅"></a>服务订阅</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务订阅消费入口：ReferenceBean.class</span></span><br><span class="line">Protocol$Adaptive --&gt; ProtocolFilterWrapper --&gt; ProtocolListenerWrapper --&gt; QosProtocolWrapper --&gt; RegistryProtocol (refer) --&gt; AbstractRegistryFactory (getRegistry) --&gt; ZookeeperRegistryFactory（createRegistry） --&gt; FailbackRegistry (register) --&gt;  ZookeeperRegistry (doRegister) </span><br><span class="line"><span class="comment">// 注册流程结束</span></span><br><span class="line"><span class="comment">// 订阅流程开始</span></span><br><span class="line">--&gt; ProxyFactory$Adaptive --&gt; StubProxyFactoryWrapper （getProxy，模板）--&gt; JavassistProxyFactory</span><br></pre></td></tr></table></figure>
<p>服务订阅的主要操作流程包括：1、创建NettyClient跟服务器建立连接；2、注册服务到注册中心；3、返回代理对象给调用端；</p>
<p>服务订阅的入口为ReferenceBean，同样由于实现了InitializingBean，所以会通过afterPropertiesSet方法进行服务订阅流程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span></span>;</span><br></pre></td></tr></table></figure>
<p>afterPropertiesSet方法通过层层调用最后会通过ReferenceConfig#init方法来进行初始化的操作，最终通过createProxy来创建代理对象，并将引用指向ref属性；createProxy中的操作可以分为两步</p>
<ul>
<li>通过protocol@Adaptive的refer方法将服务信息封装成invoker</li>
<li>通过proxyFactory.getProxy创建一个服务代理对象</li>
</ul>
<h3 id="封装Invoker"><a href="#封装Invoker" class="headerlink" title="封装Invoker"></a>封装Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// creteProxy方法代码片段</span></span><br><span class="line"><span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">    URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">        invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">        <span class="comment">// use AvailableCluster only when register's cluster is available</span></span><br><span class="line">        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">        invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url</span></span><br><span class="line">        invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们只配置了一个注册中心，那么会通过Protocol@Adaptive的refer方法去获取对应的invoker对象，如果配置了多个注册中心，那么会依次先通过Protocol@Adaptive的refer去获取invoker对象，然后再将invoker对象封装成StaticDirectory对象，最后通过Cluster@Adaptive的join方法去包装StaticDirectory，返回包装后的Invoker，作用于服务调用阶段；</p>
<p>Protocol@Adaptive的refer跟前面说的一样，会先通过层层wrapper，最后作用到RegistryProtocol对象中，RegistryProtocol中会去获取对应的Registry对象，很明显这里是ZookeeperRegistry，最后通过doRefer完成以下动作</p>
<ul>
<li>将消费者的信息注册到注册中心中</li>
<li>封装RegistryDirectory对象进行发布订阅操作，同时将directory对象通过Cluster@Adaptive进行包装成Invoker对象；</li>
</ul>
<h4 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h4><blockquote>
<p>RegistryDirectory是一个目录服务，当注册中心中的注册服务发生变更的时候，会触发RegistryDirectory的监听事件，去刷新提供者的invoker信息；</p>
</blockquote>
<p>通过RegistryDirectory的subscribe去发布订阅实际上是通过registry的发布订阅操作去实现的，所以最终会为传递进去的节点建立监听服务，而传递给registry的监听事件为this对象，所以当监听节点下的服务发生变动的时候，RegistryDirectory的notify方法会被触发；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegistryProtocol#doRefer</span></span><br><span class="line">directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">                                              <span class="comment">// providers</span></span><br><span class="line">                                              Constants.PROVIDERS_CATEGORY+ <span class="string">","</span>+ </span><br><span class="line">                                              <span class="comment">// configurators</span></span><br><span class="line">                                              Constants.CONFIGURATORS_CATEGORY+<span class="string">","</span>+</span><br><span class="line">                                              <span class="comment">// routers</span></span><br><span class="line">                                              Constants.ROUTERS_CATEGORY));</span><br><span class="line"><span class="comment">// RegistryDirectory#subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以会对对应的<code>providers、configurators、routers</code>下的子节点进行监听同时获取子节点的信息，同时如果返回的子节点集合信息为空，那么会构建一个protocol为empty的url信息往下传递；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line"><span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">    urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用RegistryDirectory的notify方法时，如果传递进去的url的protocol为empty，那么执行到最后url会被清除掉，最终在进行refreshInvoker的时候，会直接不做任何操作直接返回，像上面的configurators、routers节点下因为是空的，执行对应分支的RegistryDirectory的notify时实际上是没有做任何操作的；</p>
<p>而providers不一样，当服务发布的时候，已经往providers上注册了服务节点，所以在进行providers节点下建立监听事件的时候，可以返回对应的服务节点信息；那么就会进入到refreshInvoker的toInvokers操作，将url信息转换成url和invoker的映射关系Map，进而转换成Method和Invoker集合的映射关系；</p>
<p>toInvokers中同样会用Protocol@Adaptive根据url中的protocol去执行对应的refer操作，在这里url中的protocol为dubbo，因此先会到对应的wrapper，最后进入到DubboProtocol的refer操作中，并将返回的Invoker对象封装成InvokerDelegate，再经过wrapper的包装返回；</p>
<h4 id="DubboProtocol建立连接"><a href="#DubboProtocol建立连接" class="headerlink" title="DubboProtocol建立连接"></a>DubboProtocol建立连接</h4><p>DubboProtocol的refer操作中会通过getClients根据url去建立Netty连接，同时将服务等信息封装成一个DubboInvoker对象返回，步骤如下</p>
<ul>
<li>通过getClients去获ExchangeClient对象，在默认没配置connections属性情况下，会去获取一个共享连接客户端，最终通过initClient去初始化客户端信息，将客户端信息建立映射关系起来。如果配置了connections属性，那么connections等于多少，就会初始化多少个客户端；</li>
<li>在initClient中通过Exchangers的connect去建立连接，Exchanger也是一个扩展点，最终会获取到一个默认的HeaderExchanger对象，最终将封装好的ExchangeHandlerAdapter对象传递给HeaderExchanger进行connect的操作；</li>
<li>HeaderExchanger的connect操作会将handler进行封装，再通过Transporters进行connect的操作返回Client对象，通过HeaderExchangeClient的构造方法进行注入，最终返回一个HeaderExchangeClient对象；</li>
<li>Transporters实际上也是一个扩展点，实际上获取到的会是一个Transporters@Adaptive对象，最终会通过默认的实现NettyTransporter进行connect的操作；</li>
<li>NettyTransporter的connect操作实际上会返回一个NettyClient服务，底层最终基于Netty进行建立连接；</li>
</ul>
<h3 id="创建服务代理对象"><a href="#创建服务代理对象" class="headerlink" title="创建服务代理对象"></a>创建服务代理对象</h3><p>在RegistryProtocol的refer操作返回Invoker对象后，Dubbo会通过proxyFactory.getProxy(invoker)来创建具体的代理服务对象，前面说了proxyFactory是一个自适应扩展点，所以这里为ProxyFactory@Adaptive，经过对应wrapper进行包装后，通过JavassistProxyFactory的getProxy方法来完成代理对象的创建；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavassistProxyFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavassistProxyFactory底层是通过生成字节码操作来完成代理对象的创建的，类似于JDK的动态代理，最终返回一个@Proxy对象，而在方法调用的时候，会进去到InvokerInvocationHandler中去执行；</p>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>在服务订阅过程中，已经通过ProxyFactory的自适应扩展点创建了一个代理对象，其中构造了一个InvokerInvocationHandler对象，而我们在获取到代理对象进行真正调用的时候，内部实现会通过调用InvokerInvocationHandler.invoke去完成调用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显除了代理类的原始对象不是Object或者执行的方法不是<code>toString、hashCode、equals</code>之一时，会通过之前封装的invoker进行调用，同时会将方法及参数封装成RpcInvocation对象；</p>
<p>前面分析过，在获取到RegistryDirectory之后，会通过cluster的自适应扩展点进行join的操作，最终实际上传递到InvokerInvocationHandler中的invoker对象默认为<code>MockClusterInvoker(FailoverClusterInvoker)</code>；</p>
<h3 id="MockClusterInvoker"><a href="#MockClusterInvoker" class="headerlink" title="MockClusterInvoker"></a>MockClusterInvoker</h3><p>MockClusterInvoker会判断请求参数中是否配置了<code>mock</code>属性，mock属性用于配置熔断操作，也就是如果请求出现异常或者超时的时候，如果配置了mock属性，那么在出现异常的时候会执行mock指定的类对象去执行对应方法。</p>
<p>mock配置规则</p>
<ul>
<li>如果直接配置为true或者default，那么会用method所在类的路径找XXXMock执行；</li>
<li>如果mock指定的<code>包.类</code>名称是以<code>force</code>开头的，那么Dubbo会认为你要覆盖执行，不会走远程调用，直接调用mock指定的类去执行；</li>
</ul>
<p>默认没有配置mock的情况下，进去到MockClusterInvoker之后会继续调用包装的invoker的invoke方法，这个时候就会调用到FailoverClusterInvoker中去，FailoverClusterInvoker是Dubbo提供容错的一种默认的方式，Dubbo一共提供以下几种容错方式</p>
<ul>
<li>failover：失败自动切换，重试其他服务器，默认配置重试次数为2，加上本身调用，即有3次调用机会；</li>
<li>failfast：快速失败，失败后抛异常；</li>
<li>failsafe：失败安全，失败后不抛异常，直接忽略异常；</li>
<li>failback：失败自动恢复，后台会记录失败请求，定时重试；</li>
<li>forking：多个服务器并行访问，其中一个成功即返回进行调用；</li>
<li>broadcast：广播所有的提供者，如果有一台报错，那么就报异常；</li>
<li>available：如果服务可用，则进行调用；</li>
</ul>
<p>调用FailoverClusterInvoker的invoke方法，会通过RegistryDirectory去获取所有的Invoker对象，RegistryDirectory中存放着一个Method和List<invoker>的映射，所以可以通过RpcInvocation中的Method进行获取；获取到Invoker集合后，如果集合不为空，那么会去获取一个负载均衡LoadBalance的自适应扩展点，默认会得到随机的负载均衡器；</invoker></p>
<p>Dubbo提供以下的负载均衡器（负载均衡只对以上<code>failover、failfast、failsafe、failback</code>容错方式生效）</p>
<ul>
<li>random：随机+权重</li>
<li>roundrobin：轮训+权重</li>
<li>leastactive：最少活跃数+权重，如果活跃数相同，用随机+权重</li>
<li>consistenthash：一致性哈希</li>
</ul>
<p>通过负载均衡器拿到唯一的Invoker对象后，继续调用对应的invoke方法，实际上为RegistryDirectory$InvokerDelegate对象，最终会调用到DubboInvoker中，期间会经过<code>ProtocolXXXWrapper</code>的包装。到DubboInvoker后通过保存在内存中的ExchangeClient，最终通过NettyClient进行请求的发送；</p>
<h2 id="服务响应"><a href="#服务响应" class="headerlink" title="服务响应"></a>服务响应</h2><p>Netty服务进行交互最终会通过<code>NettyHandler.messageReceived</code>接收消息并进行处理，在<code>NettyHandler.messageReceived</code>中会通过handler链进行处理。handler链为在服务发布过程中在DubboProtocol进行bind操作时创建的，依次为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol$ExchangeHandlerAdapter --&gt; HeaderExchangeHandler --&gt; DecodeHandler --&gt;AllChannelHandler --&gt; HeartbeatHandler --&gt; MultiMessageHandler</span><br></pre></td></tr></table></figure>
<p>因此在NettyHandler.messageReceived中进行调用的时候会是相反顺序的，依次为：</p>
<ul>
<li>MultiMessageHandler：复合消息处理器，如果消息是复合消息，循环处理</li>
<li>HeartbeatHandler：心跳消息处理器，如果是心跳请求或者心跳响应，执行对应的心跳逻辑</li>
<li>AllChannelHandler：业务消息处理器，通过开启线程池的方式进行处理</li>
<li>DecodeHandler：消息解码处理器，对消息进行解码操作</li>
<li>HeaderExchangeHandler：头信息交换处理器，对业务做不同的分发处理，决定后续handler的处理方法。在这里进行服务调用时，会调用到下一个handler的reply方法进行处理</li>
<li>DubboProtocol$ExchangeHandlerAdapter：消息交换适配器，具体的业务处理类</li>
</ul>
<p>DubboProtocol$ExchangeHandlerAdapter的reply方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">        Invocation inv = (Invocation) message;</span><br><span class="line">        Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">        <span class="comment">// need to consider backward-compatibility if it's a callback</span></span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">            String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);</span><br><span class="line">            <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || methodsStr.indexOf(<span class="string">","</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String[] methods = methodsStr.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                        hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName()</span><br><span class="line">                                                      + <span class="string">" not found in callback service interface ,invoke will be ignored."</span></span><br><span class="line">                                                      + <span class="string">" please update the api interface. url is:"</span></span><br><span class="line">                                                      + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: "</span></span><br><span class="line">                                + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">": "</span> + message))</span><br><span class="line">                                + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reply方法中主要是通过getInvoker去获取Invoker对象，然后进行调用对应的invoke方法。</p>
<p>getInvoker方法内部是首先先从<code>exporterMap</code>中去获取exporter对象，再去获取封装在其内部的Invoker对象；</p>
<p>而exporterMap中主要是在服务启动去暴露服务的时候设置进去的，设置逻辑在DubboProtocol中的export方法中，export方法中传递进来的Invoker对象也是经过了几层封装</p>
<ul>
<li>先通过proxyFactory.getInvoker去将真实调用对象封装成一个Invoker，主要是通过JavassistProxyFactory的getInvoker获取代理对象，返回一个AbstractProxyInvoker对象</li>
<li>将获得到的代理对象封装到DelegateProviderMetaDataInvoker对象中</li>
<li>在进入DubboProtocol中之前，Invoker对象被ProtocolFilterWrapper构建的过滤器链进行了装饰，最后在DubboProtocol中封装成DubboExporter对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>因此在DubboProtocol$ExchangeHandlerAdapter中进行invoke调用的时候，实际上最终会进入到JavassistProxyFactory的invoke方法，最终调用到AbstractProxyInvoker对象中的doInvoke中；JavassistProxyFactory的getInvoker方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现AbstractProxyInvoker的doInvoke方法主要也是通过wrapper进行调用的，而wrapper是一个通过生成字节码的方式生成的一个代理类，最终会调用到proxy中的方法，也就是我们在服务发布时暴露的真正提供功能的具体实现类中；</p>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>Dubbo在进行DubboProtocol绑定的时候，会构建一个HeaderExchangeServer对下，而Dubbo的心跳机制是通过HeaderExchangeServer来处理的，而HeaderExchangeServer内部实际上是通过定时线程池ScheduledExecutorService实现的；</p>
<p>在构造HeaderExchangeServer对象的时候，构造器中会调用<code>startHeatbeatTimer()</code>方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 停止心跳定时器</span></span><br><span class="line">    stopHeartbeatTimer();</span><br><span class="line">    <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果配置的心跳间隔时间大于0，那么开启心跳定时器，内部线程通过netty进行发送请求</span></span><br><span class="line">        heatbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> HeartBeatTask( <span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.unmodifiableCollection(</span><br><span class="line">                        HeaderExchangeServer.<span class="keyword">this</span>.getChannels() );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">            heartbeat, heartbeat,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeaderExchangeServer的有几个关键属性，如下</p>
<ul>
<li>heartbeat：代表的是心跳间隔时间</li>
<li>heartbeatTimeout：代表的是心跳超时时间，默认为心跳间隔的三倍</li>
</ul>
<p>定时器内部的实现逻辑为</p>
<ul>
<li>如果最后一次读或者最后一次写跟当前时间的间隔大于heartbeat配置的时间（单位毫秒），那么会重新发起一个心跳请求；</li>
<li>而如果最后一次读跟当前时间的间隔大于heartbeatTimeout配置的时间，那么Dubbo会认为心跳丢失，连接超时，那么会通过Netty进行重连操作；</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/16/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="鍾欽鎮">
            
              <p class="site-author-name" itemprop="name">鍾欽鎮</p>
              <p class="site-description motion-element" itemprop="description">他强由它强 清风拂山岗 他横由他横 明月照大江</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SPI机制"><span class="nav-number">1.</span> <span class="nav-text">SPI机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#织入逻辑（wrapper）"><span class="nav-number">1.1.</span> <span class="nav-text">织入逻辑（wrapper）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注入逻辑（inject）"><span class="nav-number">1.2.</span> <span class="nav-text">注入逻辑（inject）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义扩展点"><span class="nav-number">1.3.</span> <span class="nav-text">自定义扩展点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件加载"><span class="nav-number">2.</span> <span class="nav-text">配置文件加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务发布"><span class="nav-number">3.</span> <span class="nav-text">服务发布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Protocol-Adaptive"><span class="nav-number">3.1.</span> <span class="nav-text">Protocol@Adaptive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RegistryProtocol"><span class="nav-number">3.1.1.</span> <span class="nav-text">RegistryProtocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtocol"><span class="nav-number">3.1.2.</span> <span class="nav-text">DubboProtocol</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegistryFactory-Adaptive"><span class="nav-number">3.2.</span> <span class="nav-text">RegistryFactory@Adaptive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZookeeperRegistry"><span class="nav-number">3.2.1.</span> <span class="nav-text">ZookeeperRegistry</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务订阅"><span class="nav-number">4.</span> <span class="nav-text">服务订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装Invoker"><span class="nav-number">4.1.</span> <span class="nav-text">封装Invoker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RegistryDirectory"><span class="nav-number">4.1.1.</span> <span class="nav-text">RegistryDirectory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtocol建立连接"><span class="nav-number">4.1.2.</span> <span class="nav-text">DubboProtocol建立连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建服务代理对象"><span class="nav-number">4.2.</span> <span class="nav-text">创建服务代理对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务调用"><span class="nav-number">5.</span> <span class="nav-text">服务调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MockClusterInvoker"><span class="nav-number">5.1.</span> <span class="nav-text">MockClusterInvoker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务响应"><span class="nav-number">6.</span> <span class="nav-text">服务响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#心跳机制"><span class="nav-number">7.</span> <span class="nav-text">心跳机制</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鍾欽鎮</span>

  

  
</div>


  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
